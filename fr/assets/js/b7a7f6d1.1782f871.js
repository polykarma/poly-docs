"use strict";(self.webpackChunkpoly_docs=self.webpackChunkpoly_docs||[]).push([[5179],{4039:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>r});const s=JSON.parse('{"id":"inf2010/hashtable","title":"HashTable","description":"Goal","source":"@site/docs/inf2010/hashtable.md","sourceDirName":"inf2010","slug":"/inf2010/hashtable","permalink":"/poly-docs/fr/docs/inf2010/hashtable","draft":false,"unlisted":false,"editUrl":"https://github.com/polykarma/poly-docs/docs/inf2010/hashtable.md","tags":[],"version":"current","lastUpdatedBy":"polykarma","lastUpdatedAt":1732169617000,"frontMatter":{"title":"HashTable"},"sidebar":"sidebar","previous":{"title":"Queues","permalink":"/poly-docs/fr/docs/inf2010/queues"},"next":{"title":"Collisions","permalink":"/poly-docs/fr/docs/inf2010/collisions"}}');var a=i(4848),t=i(8453);const l={title:"HashTable"},o="HashTable",h={},r=[{value:"Goal",id:"goal",level:2},{value:"Mechanics",id:"mechanics",level:2},{value:"Hashing function",id:"hashing-function",level:3},{value:"Optimal Hashing",id:"optimal-hashing",level:3}];function c(e){const n={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"hashtable",children:"HashTable"})}),"\n",(0,a.jsx)(n.h2,{id:"goal",children:"Goal"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Keeping data retrieval in constant while also maintaining dynamism."})}),"\n",(0,a.jsx)(n.h2,{id:"mechanics",children:"Mechanics"}),"\n",(0,a.jsxs)(n.p,{children:["The Hashtable is comparable in nature to an array where we are basically trying to index our data in sequential fashion. Where it differs is ",(0,a.jsx)(n.em,{children:"how"})," the data is placed, the hashing function determines the location."]}),"\n",(0,a.jsx)(n.p,{children:"Our focus needs to be on:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"resizing our table"}),"\n",(0,a.jsx)(n.li,{children:"determining a hashing function"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"hashing-function",children:"Hashing function"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Note: All types of data can be converted to an integer following a numerical ascii conversion"})}),"\n",(0,a.jsx)(n.p,{children:"A hashing function takes the hash code of your data, then applies some kind of a modulus operation on the size of the hashtable."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"For example,"})," if we have a table size of 7, and we want to insert data with a hashed value of 48, it will be inserted at index 6."]}),"\n",(0,a.jsx)(n.h3,{id:"optimal-hashing",children:"Optimal Hashing"}),"\n",(0,a.jsx)(n.p,{children:"A good hashing function:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Distributes values as uniformly (on the available keys in the memory space) as possible to reduce ",(0,a.jsx)(n.a,{href:"/poly-docs/fr/docs/inf2010/collisions",children:"collisions"})]}),"\n",(0,a.jsx)(n.li,{children:"Is easy and fast to calculate."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(6540);const a={},t=s.createContext(a);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);