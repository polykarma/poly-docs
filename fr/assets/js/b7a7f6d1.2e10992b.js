"use strict";(self.webpackChunkpoly_docs=self.webpackChunkpoly_docs||[]).push([[179],{4039:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>h,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"inf2010/hashtable","title":"HashTable","description":"Problem","source":"@site/docs/inf2010/hashtable.md","sourceDirName":"inf2010","slug":"/inf2010/hashtable","permalink":"/poly-docs/fr/docs/inf2010/hashtable","draft":false,"unlisted":false,"editUrl":"https://github.com/polykarma/poly-docs/docs/inf2010/hashtable.md","tags":[],"version":"current","frontMatter":{"title":"HashTable"},"sidebar":"sidebar","previous":{"title":"Queues","permalink":"/poly-docs/fr/docs/inf2010/queues"}}');var s=n(4848),i=n(8453);const o={title:"HashTable"},h="HashTable",r={},l=[{value:"Problem",id:"problem",level:2},{value:"Goal",id:"goal",level:2},{value:"Mechanics",id:"mechanics",level:2},{value:"Analogy",id:"analogy",level:2}];function d(e){const t={em:"em",h1:"h1",h2:"h2",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"hashtable",children:"HashTable"})}),"\n",(0,s.jsx)(t.h2,{id:"problem",children:"Problem"}),"\n",(0,s.jsx)(t.p,{children:"Arrays and LinkedLists are not always the most efficient for storing and retrieving data in specific cases."}),"\n",(0,s.jsx)(t.p,{children:"For example if we had unlimited time then perhaps we could do a sequential search to find an element in a list. If we had unlimited memory then perhaps we could store all the elements in an array."}),"\n",(0,s.jsx)(t.p,{children:"However, in the real world we have to make trade-offs between time and space. The hashtable is situated in the middle of these two extremes. It is a data structure that allows us to store and retrieve data in a more efficient manner than a list or an array."}),"\n",(0,s.jsx)(t.h2,{id:"goal",children:"Goal"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:"Explore how a hash table correlates data to placement"})}),"\n",(0,s.jsx)(t.h2,{id:"mechanics",children:"Mechanics"}),"\n",(0,s.jsx)(t.p,{children:"A hashtable works by simply converting the data we are handling into the position where it should be stored. This is done by using a hash function."}),"\n",(0,s.jsx)(t.p,{children:"A hash function is a function that takes an input (or key) and returns a unique output (or hash). This hash is then used to determine the position of the data in the hashtable."}),"\n",(0,s.jsx)(t.p,{children:"Usually for alphanumeric elements, we use the combination of the ASCII values of the characters in the key to generate the hash. This is a simple hash function that is easy to implement."}),"\n",(0,s.jsx)(t.p,{children:"We then take that integer key and use it to determine the position of the data in the hashtable by using modulo."}),"\n",(0,s.jsx)(t.h2,{id:"analogy",children:"Analogy"}),"\n",(0,s.jsx)(t.p,{children:"A hashtable can be visualized as a library. When you want to find a book in a library, you don't search through every book in the library. Instead, you check the author's name, the title of the book, or the ISBN number. This information is used to determine the location of the book in the library."})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>h});var a=n(6540);const s={},i=a.createContext(s);function o(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function h(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);